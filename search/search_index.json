{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"P\u00e1gina Web Bit\u00e1cora","text":"<p>Soy Sebasti\u00e1n S\u00e1nchez Escobar, estudi\u00f3 ingenier\u00eda Mecatr\u00f3nica en la Ibero Puebla, voy en primer semestre, me gustar\u00eda aprender m\u00e1s sobre la automatizaci\u00f3n e industria 4.0. Me gusta escuchar m\u00fasica, entrenar y salir con mis amigos. </p> <p>Me siento orgulloso de la disciplina que he construido y he desmostrado en varias ocasiones, gracias a este esfuerzo he desarrollado y mantenido buenos h\u00e1bitos que mejoran mi vida.</p> <p>Mi correo es: 196866@iberopuebla.mx </p> <p></p>"},{"location":"#trabajosproyectos","title":"Trabajos/Proyectos","text":""},{"location":"#controlar-luz-led-por-bluetooth","title":"Controlar luz LED por Bluetooth.","text":"<p>En este trabajo controlamos el encendido y apagado de una luz LED con un tel\u00e9fono mediante Bluetooth. Ocupamos: Protoboard, ESP 32, LED.</p>"},{"location":"#controlar-luz-led-con-boton","title":"Controlar luz LED con boton.","text":"<p>En este trabajo controlamos el encendido y apagado de una luz LED con un bot\u00f3n. Ocupamos: Protoboard, ESP 32, LED, bot\u00f3n.</p>"},{"location":"#cambio-de-giro-de-motor","title":"Cambio de giro de motor","text":"<p>En este trabajo controlamos la direcci\u00f3n de giro de un motor. Ocupamos: Protoboarb, ESP 32, Puente H, Motorreductor TT.</p>"},{"location":"#cambio-gradual-de-velocidad-de-motor","title":"Cambio gradual de velocidad de motor","text":"<p>Aqui el mismo circuito que en el trabajo pasado, pero cambiamos el c\u00f3digo del ESP32 para que gradualmente cambie la velocidad.</p>"},{"location":"#servomotor-ciclo-0-10-0-20-0-30-hasta-180","title":"Servomotor ciclo 0\u00b0-10\u00b0-0\u00b0-20\u00b0-0\u00b0-30\u00b0... hasta 180\u00b0","text":"<p>En este trabajo hicimos que un servomotor fuera aumentando de 10\u00b0 en 10\u00b0 pero regresando a 0\u00b0 entre cada subida. Ocupamos: Protoboarb, ESP 32, servomotor.</p>"},{"location":"#proyecto-coche-a-control-remoto-bluetooth","title":"PROYECTO: Coche a control remoto Bluetooth","text":"<p>En este proyecto construimos un coche a control remoto Bluetooth. El material que usamos para el coche:   - 4 Motorreductores TT   - 4 Llantas Omnidireccionales   - 2 Puentes H - 1 Protoboard  - 1 ESP 32 - Jumpers - 2 Pilas - Control Xbox Las 2 Pilas se conectan para alimentar todo el sistema. Los Puentes H se usan para poder controlar los 4 motores TT (1 Puente H por 2 motores TT), cada Puente H controla la direcci\u00f3n y velocidad de dos motores a la vez.  El ESP32 se pone en la Protoboard y se conecta a las entradas de los Puentes H usando Jumpers.   El c\u00f3digo dentro del ESP32 est\u00e1 configurado para conectarse al control Xbox, luego lee el movimiento del joystick y dependiendo de la direcci\u00f3n del joystick se activa una funci\u00f3n para que los motores se activen de manera espec\u00edfica para moverse en esa direcci\u00f3n. </p>"},{"location":"#codigo-python-vision-por-camara-dibujar-en-camara","title":"C\u00f3digo Python Vision por C\u00e1mara, dibujar en c\u00e1mara","text":"<p>En este trabajo logramos iniciar la c\u00e1mara en python, modificar los colores y dibujar l\u00edneas y circulos. <pre><code>import cv2\nimport numpy as np\n\nvideo = cv2.VideoCapture(0)\n\n#centrox=0\n#centroy=0\n\nwhile True:\n\n    ret, img = video.read()\n\n    #img2 = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)\n    #img3 = cv2.cvtColor(img, cv2.COLOR_RGB2BGR)\n    #img4 = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)\n\n    if not ret:\n        break\n\n\n    cv2.imshow(\"Mivideo\",img)\n\n\n\n    #DIBUJAR COSAS\n    #draw = img.copy ()\n    #LINEA\n    #cv2.line(draw,(0,0),(100,100),(0,0,255),thickness=3, lineType=cv2.LINE_AA)\n    #CIRCULO\n    #cv2.circle(draw,(centrox,centroy),50,(0,0,255),thickness=3, lineType=cv2.LINE_AA)\n    #cv2.imshow(\"Mivideodraw\",draw)\n    #centrox=centrox+1\n    #if centrox&lt;300:\n    #    centrox=centrox+1\n    #else:\n    #    centrox=0\n\n\n    #CAMBIOS DE COLORES\n    #imgCopia = img.copy()\n    #imgCopia[:, :, 1] = 0\n    #imgCopia[:, :, 0] = 0\n    #imgCopia[0:300, 0:300, 2] = 0\n\n    #MOSTRAR IMAGEN\n    #cv2.imshow(\"Mivideo1\",img2)\n    #cv2.imshow(\"Mivideo2\",img3)\n    #cv2.imshow(\"Mivideo3\",img4)\n    #cv2.imshow(\"Mivideo\",no_blue)\n    if cv2.waitKey(1) &amp; 0xFF == ord('q'):\n        break\n\nvideo.release()\ncv2.destroyAllWindows()\n</code></pre></p>"},{"location":"#codigo-python-vision-por-camara-rastreo-de-cara","title":"C\u00f3digo Python Vision por c\u00e1mara. Rastreo de cara","text":"<p>Este c\u00f3digo Python utiliza OpenCV para realizar detecci\u00f3n de rostros en tiempo real. Esto lo logra cargando un modelo pre-entrenado de detecci\u00f3n de rostros basado en Caffe. Si encuentra un rostro con una confianza superior al umbral (detection_treshold), dibuja un cuadrado de color verde y muestra el valor de la confianza que cree que sea un rostro alrededor del rostro.</p> <pre><code>import cv2\nimport numpy as np\n\nvideo = cv2.VideoCapture(0)\n\n#variables de detecci\u00f3n\n\nmean = [104,117,123]\nscale = 1.0\nin_width = 300\nin_height = 300\n\ndetection_treshold = 0.5\n\nnet = cv2.dnn.readNetFromCaffe('models/deploy.prototxt', 'models/res10_300x300_ssd_iter_140000.caffemodel')\n\ndef detect(frame, net, scale, in_width, in_height):\n    h = frame.shape[0]\n    w = frame.shape[1]\n    blob = cv2.dnn.blobFromImage(frame, scalefactor=scale,\n                                 size=(in_width, in_height), mean=mean, swapRB=False, crop=False)\n    # Pasar el blob a la red\n    net.setInput(blob)\n    # Pasra el blob a la red\n    detections = net.forward()\n\n    # Procesar las detecciones\n    for i in range(detections.shape[2]):\n        confidence = detections[0, 0, i, 2]\n        if confidence &gt; detection_treshold:\n\n            #Extraer las coordenadas del bounding box de la detecci\u00f3n\n            box = detections[0, 0, i, 3:7] * np.array([w, h, w, h])\n            (x1, y1, x2, y2) = box.astype('int')\n\n            # Dibujar el bounding box y el texto\n            cv2.rectangle(frame, (x1, y1), (x2, y2), (0, 255, 0), 2)\n            label = 'Confidence: %.4f' % confidence\n            label_size, base_line = cv2.getTextSize(label, cv2.FONT_HERSHEY_SIMPLEX, 0.5, 1)\n            cv2.rectangle(frame, (x1, y1 - label_size[1]), (x1 + label_size[0], y1 + base_line),\n                          (255, 255, 255), cv2.FILLED)\n            cv2.putText(frame, label, (x1, y1),  cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 0, 0))\n    return frame\n\n#centrox=0\n#centroy=0\n\nwhile True:\n\n    ret, img = video.read()\n\n    #img2 = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)\n    #img3 = cv2.cvtColor(img, cv2.COLOR_RGB2BGR)\n    #img4 = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)\n\n    if not ret:\n        break\n\n    img2 = detect(img,net, scale, in_width, in_height)\n    cv2.imshow(\"Mivideo\",img2)\n\n    #draw = img.copy ()\n    #LINEA\n    #cv2.line(draw,(0,0),(100,100),(0,0,255),thickness=3, lineType=cv2.LINE_AA)\n    #CIRCULO\n    #cv2.circle(draw,(centrox,centroy),50,(0,0,255),thickness=3, lineType=cv2.LINE_AA)\n    #cv2.imshow(\"Mivideodraw\",draw)\n    #centrox=centrox+1\n    #if centrox&lt;300:\n    #    centrox=centrox+1\n    #else:\n    #    centrox=0\n\n\n    #CAMBIOS DE COLORES\n    #no_blue = img.copy()\n    #no_blue[:, :, 1] = 0\n    #no_blue[:, :, 0] = 0\n    #no_blue[0:300, 0:300, 2] = 0\n\n    #MOSTRAR IMAGEN\n    #cv2.imshow(\"Mivideo1\",img2)\n    #cv2.imshow(\"Mivideo2\",img3)\n    #cv2.imshow(\"Mivideo3\",img4)\n    #cv2.imshow(\"Mivideo\",no_blue)\n    if cv2.waitKey(1) &amp; 0xFF == ord('q'):\n        break\n\nvideo.release()\ncv2.destroyAllWindows()\n</code></pre>"},{"location":"#codigo-python-vision-por-camara-dibujar-circulo-alrededor-de-pelota","title":"C\u00f3digo Python Vision por c\u00e1mara. Dibujar circulo alrededor de pelota.","text":"<p>Este c\u00f3digo busca el controno mayor redondo que sea de color verde para marcarlo con un circulo amarillo de seguimiento.</p> <pre><code>import cv2\nimport numpy as np\n\ncap = cv2.VideoCapture(0)  \n\nwhile True:\n    ok, img = cap.read()\n    if not ok:\n        break\n\n    #mostrar camara normal\n    cv2.imshow(\"Frame\", img)\n\n    #cambio a hsv\n    hsv = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)\n\n    #hacer mascara, solo mostrar un color\n    low  = np.array([35,  60,  60], dtype=np.uint8) # low es\n    high = np.array([85, 255, 255], dtype=np.uint8)\n    mask = cv2.inRange(hsv, low, high)\n\n    #mascara final\n    seg = cv2.bitwise_and(img, img, mask=mask)\n\n    #hacer contorno\n    contours, _ = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n    out = img.copy()\n\n\n    area_mayor = 0\n    #checar area mayor\n    for actual in contours:\n        area = cv2.contourArea(actual)\n        if area &gt; area_mayor:\n            area_mayor=area\n            contorno_mayor=actual\n        else: \n            continue\n\n    cv2.drawContours(seg, contorno_mayor, -1, (0,255,0), 2)\n\n    (x, y), radius = cv2.minEnclosingCircle(contorno_mayor)\n    cv2.circle(out, (int(x), int(y)), int(radius), (0,255,255), 2)\n    cv2.circle(out, (int(x), int(y)), 2, (0,0,255), 2)\n\n    #cv2.imshow(\"Mask\", mask) #mascara\n    #cv2.imshow(\"Segmentado\", seg)  #mascara final con color\n    #cv2.imshow(\"hsv\", hsv) \n\n    cv2.imshow(\"contornos\", out)\n\n    if cv2.waitKey(1) &amp; 0xFF == ord('x'):\n        break\n\ncap.release()\ncv2.destroyAllWindows()\n</code></pre>"},{"location":"#codigo-python-vision-por-camara-calcular-diferencia-centro-pelota-a-centro-camara","title":"C\u00f3digo Python Vision por c\u00e1mara. Calcular diferencia centro pelota a centro c\u00e1mara","text":"<p>Este c\u00f3digo realiza seguimiento de una pelota verde y calcula la posici\u00f3n relativa del objeto respecto al centro de la c\u00e1mara. Es una versi\u00f3n de seguimiento visual sin la parte de comunicaci\u00f3n Bluetooth.</p> <pre><code>import cv2\nimport time\nimport numpy as np\n\ncap = cv2.VideoCapture(0)  \n\nwhile True:\n    ok, img = cap.read()\n    cv2.flip(img, 1,img)\n    if not ok:\n        break\n\n    width = int(cap.get(cv2.CAP_PROP_FRAME_WIDTH))\n    height = int(cap.get(cv2.CAP_PROP_FRAME_HEIGHT))\n\n\n\n    #mostrar camara normal\n    cv2.imshow(\"Frame\", img)\n\n    #cambio a hsv\n    hsv = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)\n\n    #hacer mascara, solo mostrar un color\n    low  = np.array([35,  60,  60], dtype=np.uint8) # low es\n    high = np.array([85, 255, 255], dtype=np.uint8)\n    mask = cv2.inRange(hsv, low, high)\n\n    #mascara final\n    seg = cv2.bitwise_and(img, img, mask=mask)\n\n    #hacer contorno\n    contours, _ = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n    out = img.copy()\n\n\n    area_mayor = 0\n    #checar area mayor\n    for actual in contours:\n        area = cv2.contourArea(actual)\n        if area &gt; area_mayor:\n            area_mayor=area\n            contorno_mayor=actual\n        else: \n            continue\n\n    cv2.drawContours(seg, contorno_mayor, -1, (0,255,0), 2)\n\n\n    (x, y), radius = cv2.minEnclosingCircle(contorno_mayor)\n    cv2.circle(out, (int(x), int(y)), int(radius), (0,255,255), 2)\n    cv2.circle(out, (int(x), int(y)), 2, (0,0,255), 2)\n\n    cv2.putText(out, f\"x:{int(x)}, Y: {int(y)}\", (0,30),cv2.FONT_HERSHEY_SIMPLEX, 0.5, (255,0,0), 2)\n\n    #calcular si esta en el centro x, y\n    centrox = width // 2\n    centroy = height // 2\n    ErrorX = int(x) - centrox\n    ErrorY = int(y) - centroy\n\n\n    if ErrorX &gt; 0:\n        direccionX = \"Derecha\"\n    elif ErrorX &lt; 0:\n        direccionX = \"Izquierda\"\n    else:\n        direccionX = \"X_OK\"\n\n    if ErrorY &gt; 0:\n        direccionY = \"Abajo\"\n    elif ErrorY &lt; 0:\n        direccionY = \"Arriba\"\n    else:\n        direccionY = \"Y_OK\"\n\n    cv2.putText(out, f\"{direccionX}, {direccionY}\", (0,100),cv2.FONT_HERSHEY_SIMPLEX, 0.5, (255,0,0), 2)\n\n    #cv2.imshow(\"Mask\", mask) #mascara\n    #cv2.imshow(\"Segmentado\", seg)  #mascara final con color\n    #cv2.imshow(\"hsv\", hsv) \n\n    cv2.imshow(\"contornos\", out) \n\n    if cv2.waitKey(1) &amp; 0xFF == ord('x'):\n        break\n\ncap.release()\ncv2.destroyAllWindows() \n</code></pre>"},{"location":"#codigo-python-vision-por-camara-enviar-datos-a-esp32","title":"C\u00f3digo Python Vision por c\u00e1mara. Enviar datos a ESP32","text":"<p>Este c\u00f3digo es pr\u00e1cticamente lo mismo que al anterior pero este envia los datos calculados de error X y error Y al ESP32.</p> <pre><code>import cv2\nimport numpy as np\nimport bluetooth\nimport time\n\ncap = cv2.VideoCapture(0)  \n\n\n\n# FUNCTION TO CONNECT TO ESP32\nport = 1\nsock = bluetooth.BluetoothSocket()  # Use the default constructor (no arguments)\nsock.settimeout(20)\n\nprint(\"Attempting to connect to ESP32...\")\nwhile True:\n    try:\n        sock.connect((\"FC:B4:67:F1:8B:22\", port)) #cambiar la direccion BT esp32\n        print(\"Connected to ESP32!\")\n        break\n    except Exception as e:\n        print(\"Error in connection... retrying:\", e)\n    time.sleep(1)\n\n\n\nwhile True:\n\n    ok, img = cap.read()\n    cv2.flip(img, 1,img)\n    if not ok:\n        break\n\n    #mostrar camara normal\n    cv2.imshow(\"Frame\", img)\n\n    #cambio a hsv\n    hsv = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)\n\n    #hacer mascara, solo mostrar un color\n    low  = np.array([35,  60,  60], dtype=np.uint8) # low es\n    high = np.array([85, 255, 255], dtype=np.uint8)\n    mask = cv2.inRange(hsv, low, high)\n\n    #mascara final\n    seg = cv2.bitwise_and(img, img, mask=mask)\n\n    #hacer contorno\n    contours, _ = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n    out = img.copy()\n\n\n    area_mayor = 0\n    #checar area mayor\n    for actual in contours:\n        area = cv2.contourArea(actual)\n        if area &gt; area_mayor:\n            area_mayor=area\n            contorno_mayor=actual\n        else: \n            continue\n\n    cv2.drawContours(seg, contorno_mayor, -1, (0,255,0), 2)\n\n\n\n    (x, y), radius = cv2.minEnclosingCircle(contorno_mayor)\n    cv2.circle(out, (int(x), int(y)), int(radius), (0,255,255), 2)\n    cv2.circle(out, (int(x), int(y)), 2, (0,0,255), 2)\n\n    cv2.putText(out, f\"x:{int(x)}, Y: {int(y)}\", (0,30),cv2.FONT_HERSHEY_SIMPLEX, 0.5, (255,0,0), 2)\n\n    #calcular si esta en el centro x, y\n    centrox = img.shape[1] // 2\n    centroy = img.shape[0] // 2\n    ErrorX = int(x) - centrox\n    ErrorY = int(y) - centroy\n\n\n    if ErrorX &gt; 0:\n        direccionX = \"Derecha\"\n        try:\n            sock.send(direccionX.encode())  # encode the string to bytes\n            print(\"Sent:\",direccionX)\n        except Exception as e:\n            print(\"Error sending data:\", e)\n    elif ErrorX &lt; 0:\n        direccionX = \"Izquierda\"\n        try:\n            sock.send(direccionX.encode())  # encode the string to bytes\n            print(\"Sent:\",direccionX)\n        except Exception as e:\n            print(\"Error sending data:\", e)\n    else:\n        direccionX = \"X_OK\"\n        try:\n            sock.send(direccionX.encode())  # encode the string to bytes\n            print(\"Sent:\",direccionX)\n        except Exception as e:\n            print(\"Error sending data:\", e)\n\n    if ErrorY &gt; 0:\n        direccionY = \"Abajo\"\n        try:\n            sock.send(direccionY.encode())  # encode the string to bytes\n            print(\"Sent:\",direccionY)\n        except Exception as e:\n            print(\"Error sending data:\", e)\n    elif ErrorY &lt; 0:\n        direccionY = \"Arriba\"\n        try:\n            sock.send(direccionY.encode())  # encode the string to bytes\n            print(\"Sent:\",direccionY)\n        except Exception as e:\n            print(\"Error sending data:\", e)\n    else:\n        try:\n            sock.send(direccionY.encode())  # encode the string to bytes\n            print(\"Sent:\",direccionY)\n        except Exception as e:\n            print(\"Error sending data:\", e)\n        direccionY = \"Y_OK\"\n\n    cv2.putText(out, f\"{direccionX}, {direccionY}\", (0,100),cv2.FONT_HERSHEY_SIMPLEX, 0.5, (255,0,0), 2)\n\n\n    #cv2.imshow(\"Mask\", mask) #mascara\n    #cv2.imshow(\"Segmentado\", seg)  #mascara final con color\n    #cv2.imshow(\"hsv\", hsv) \n\n    cv2.imshow(\"contornos\", out) \n\n    if cv2.waitKey(1) &amp; 0xFF == ord('x'):\n        break\n\ncap.release()\ncv2.destroyAllWindows()\n</code></pre>"},{"location":"ProyectoFinal/","title":"PROYECTO: Robot con Visi\u00f3n por Computadora y Control PID","text":""},{"location":"ProyectoFinal/#descripcion-general","title":"Descripci\u00f3n General","text":"<p>Este proyecto consiste en un robot balanceador con plataforma m\u00f3vil, controlado mediante visi\u00f3n por computadora (OpenCV) y estabilizado con dos servomotores MG996R. El sistema detecta una pelota azul sobre una plataforma negra y ajusta la inclinaci\u00f3n mediante un control PID en tiempo real.</p> <p>El robot fue construido utilizando:</p> <ul> <li>2 servomotores MG996R de 15 kg</li> <li>Estructura y articulaciones impresas en 3D</li> <li>Plataforma de MDF</li> <li>ESP32 con comunicaci\u00f3n por Bluetooth</li> <li>Python + OpenCV para visi\u00f3n por computadora</li> </ul>"},{"location":"ProyectoFinal/#autores","title":"Autores","text":"<ul> <li>Eduardo Salamanca</li> <li>Juan Carlos P\u00e9rez</li> <li>Andr\u00e9 S\u00e1nchez</li> <li>Sebasti\u00e1n S\u00e1nchez</li> </ul>"},{"location":"ProyectoFinal/#caracteristicas-principales","title":"Caracter\u00edsticas Principales","text":"<ul> <li>Detecci\u00f3n de plataforma negra mediante segmentaci\u00f3n HSV.</li> <li>Detecci\u00f3n de pelota azul y c\u00e1lculo preciso del centro.</li> <li>Control PID ajustable en tiempo real mediante sliders en OpenCV.</li> <li>Comunicaci\u00f3n serial Bluetooth con ESP32.</li> <li>Movimientos suaves gracias a filtros y suavizado.</li> </ul>"},{"location":"ProyectoFinal/#enlace-al-video-de-funcionamiento","title":"Enlace al Video de Funcionamiento","text":"<p>Video demostrativo del robot</p> <p>Demostraci\u00f3n del sistema detectando la pelota, calculando la posici\u00f3n y moviendo los servomotores en tiempo real.</p>"},{"location":"ProyectoFinal/#hardware-utilizado","title":"Hardware Utilizado","text":"Componente Cant. Nota Servomotor MG996R 2 15 kg torque ESP32 1 Control y comunicaci\u00f3n Plataforma MDF 1 Soporte f\u00edsico Piezas impresas en 3D 4+ Articulaciones y brazos"},{"location":"ProyectoFinal/#software-utilizado","title":"Software Utilizado","text":"<ul> <li>Python 3.10+</li> <li>OpenCV</li> <li>NumPy</li> <li>PySerial</li> <li>Arduino IDE</li> </ul>"},{"location":"ProyectoFinal/#funcionamiento","title":"Funcionamiento","text":""},{"location":"ProyectoFinal/#1-deteccion-de-plataforma","title":"1. Detecci\u00f3n de Plataforma","text":"<p>Se segmenta el \u00e1rea negra mediante un threshold en HSV:</p> <p>python lower_black = np.array([0, 0, 0]) upper_black = np.array([180, 255, THRESHOLD_PLATAFORMA])</p> <p>Se obtiene el contorno m\u00e1s grande y su centro.</p>"},{"location":"ProyectoFinal/#2-deteccion-de-pelota-azul","title":"2. Detecci\u00f3n de Pelota Azul","text":"<p>python LOW_BLUE = np.array([100, 150, 70]) HIGH_BLUE = np.array([130, 255, 255])</p> <p>Se calcula centro y radio para validar detecci\u00f3n.</p>"},{"location":"ProyectoFinal/#3-calculo-de-error","title":"3. C\u00e1lculo de Error","text":"<p>python error_x = centro_pelota.x - centro_plataforma.x error_y = centro_pelota.y - centro_plataforma.y</p>"},{"location":"ProyectoFinal/#4-control-pid","title":"4. Control PID","text":"<p>python output_x = Kperror_x + Kiintegral_x + Kd*derivative_x</p> <p>Sliders en OpenCV permiten ajustar Kp, Ki y Kd.</p>"},{"location":"ProyectoFinal/#5-envio-al-esp32","title":"5. Env\u00edo al ESP32","text":"<p>python mensaje = f\"{int(current_x)},{int(current_y)}\\n\" esp32.write(mensaje.encode())</p>"},{"location":"ProyectoFinal/#mecanica","title":"Mec\u00e1nica","text":""},{"location":"ProyectoFinal/#codigo-p","title":"C\u00f3digo P","text":"<p>Python (Visi\u00f3n por Computadora)</p> <p>python import cv2 import time import numpy as np import serial import serial.tools.list_ports</p>"},{"location":"ProyectoFinal/#-configuracion-serial-bluetooth-","title":"------------------- Configuraci\u00f3n Serial Bluetooth -------------------","text":"<p>esp32_port = 'COM3' baud_rate = 115200</p> <p>print(\"=\" * 50) print(\"Intentando conectar con ESP32...\") print(f\"Puerto: {esp32_port} | Baudios: {baud_rate}\")</p> <p>def listar_puertos():     puertos = serial.tools.list_ports.comports()     print(\"\\n Puertos COM disponibles:\")     if len(puertos) == 0:         print(\"  No se encontraron puertos COM\")     for puerto in puertos:         print(f\"   \u2022 {puerto.device}: {puerto.description}\")     print()</p> <p>listar_puertos()</p> <p>try:     esp32 = serial.Serial(esp32_port, baud_rate, timeout=1)     time.sleep(2)     print(f\" \u00a1Conectado al ESP32 en {esp32_port}!\") except serial.SerialException as e:     print(f\" Error de conexi\u00f3n serial: {e}\")     print(\"\\n Posibles soluciones:\")     print(\"   1. Verifica que el puerto COM sea correcto\")     print(\"   2. Cierra el IDE de Arduino si est\u00e1 abierto\")     print(\"   3. Cierra cualquier monitor serial activo\")     print(\"   4. Desconecta y reconecta el ESP32\")     print(\"   5. Verifica que el ESP32 est\u00e9 encendido\")     esp32 = None except Exception as e:     print(f\" Error inesperado: {e}\")     esp32 = None</p> <p>print(\"=\" * 50)</p>"},{"location":"ProyectoFinal/#-configuracion-camara-","title":"------------------- Configuraci\u00f3n c\u00e1mara -------------------","text":"<p>cap = cv2.VideoCapture(1) cap.set(cv2.CAP_PROP_FRAME_WIDTH, 640) cap.set(cv2.CAP_PROP_FRAME_HEIGHT, 480)</p> <p>if not cap.isOpened():     print(\"Error: No se pudo abrir la c\u00e1mara\")     exit()</p>"},{"location":"ProyectoFinal/#-posicion-inicial-servos-","title":"------------------- Posici\u00f3n inicial servos -------------------","text":"<p>center_angle = 50 current_x = center_angle current_y = center_angle DEAD_ZONE = 15  # Zona muerta reducida smoothing = 0.3  # Suavizado reducido para respuesta m\u00e1s r\u00e1pida</p>"},{"location":"ProyectoFinal/#-parametros-pid-ajustables-","title":"------------------- Par\u00e1metros PID ajustables -------------------","text":"<p>Kp = 0.15 Ki = 0.001 Kd = 0.20</p> <p>prev_error_x = 0 prev_error_y = 0 integral_x = 0 integral_y = 0</p> <p>MAX_INTEGRAL = 50</p>"},{"location":"ProyectoFinal/#-parametros-de-deteccion-","title":"------------------- Par\u00e1metros de detecci\u00f3n -------------------","text":""},{"location":"ProyectoFinal/#threshold-para-plataforma-negra-0-255-valor-v-en-hsv","title":"Threshold para plataforma NEGRA (0-255, valor V en HSV)","text":"<p>THRESHOLD_PLATAFORMA = 120  # Ampliado para detectar m\u00e1s tonos AREA_MIN_PLATAFORMA = 1000  # \u00c1rea m\u00ednima del cuadrado</p>"},{"location":"ProyectoFinal/#rango-hsv-para-pelota-azul","title":"Rango HSV para pelota azul","text":"<p>LOW_BLUE = np.array([100, 150, 70]) HIGH_BLUE = np.array([130, 255, 255]) AREA_MIN_PELOTA = 200 RADIO_MIN_PELOTA = 8</p>"},{"location":"ProyectoFinal/#-funcion-para-limitar-valores-","title":"------------------- Funci\u00f3n para limitar valores -------------------","text":"<p>def constrain(value, min_val, max_val):     return max(min_val, min(max_val, value))</p>"},{"location":"ProyectoFinal/#-callbacks-para-sliders-","title":"------------------- Callbacks para sliders -------------------","text":"<p>def update_kp(val):     global Kp     Kp = val / 100.0  # Slider 0-100, valor real 0.00-1.00     print(f\"Kp = {Kp:.3f}\")</p> <p>def update_ki(val):     global Ki     Ki = val / 1000.0  # Slider 0-100, valor real 0.000-0.100     print(f\"Ki = {Ki:.4f}\")</p> <p>def update_kd(val):     global Kd     Kd = val / 100.0  # Slider 0-100, valor real 0.00-1.00     print(f\"Kd = {Kd:.3f}\")</p>"},{"location":"ProyectoFinal/#-crear-ventana-de-control-","title":"------------------- Crear ventana de control -------------------","text":"<p>cv2.namedWindow('Control PID') cv2.createTrackbar('Kp x100', 'Control PID', int(Kp * 100), 100, update_kp) cv2.createTrackbar('Ki x1000', 'Control PID', int(Ki * 1000), 100, update_ki) cv2.createTrackbar('Kd x100', 'Control PID', int(Kd * 100), 100, update_kd)</p> <p>prev_time = time.time() print(\"=\" * 50) print(\"Sistema de Balance: Plataforma + Pelota\") print(\"=\" * 50) print(\"CONFIGURACI\u00d3N:\") print(f\"  \u2022 Centro servos: {center_angle}\u00b0 (Rango: 0-180\u00b0)\") print(f\"  \u2022 Zona muerta: \u00b1{DEAD_ZONE} p\u00edxeles\") print(f\"  \u2022 Suavizado: {smoothing}\") print(f\"  \u2022 Threshold plataforma: {THRESHOLD_PLATAFORMA}\") print(f\"  \u2022 PID: Kp={Kp} Ki={Ki} Kd={Kd}\") print(\"\\nDETECCI\u00d3N:\") print(\"  \u2022 PLATAFORMA NEGRA (HSV): Detecta \u00e1rea m\u00e1s grande de tonos oscuros\") print(\"  \u2022 PELOTA AZUL: Posici\u00f3n para calcular error\") print(\"  \u2022 Usa teclas '1'/'2' para ajustar threshold\") print(\"\\nCONTROLES:\") print(\"  \u2022 'q' \u2192 Salir\") print(\"  \u2022 'c' \u2192 Resetear integrales\") print(\"  \u2022 '1' \u2192 Threshold -5\") print(\"  \u2022 '2' \u2192 Threshold +5\") print(\"  \u2022 Sliders \u2192 Ajustar PID en tiempo real\") print(\"=\" * 50)</p> <p>frame_count = 0 fps_time = time.time() fps = 0</p> <p>while True:     ret, frame = cap.read()     if not ret:         print(\"Error: No se pudo leer frame de la c\u00e1mara\")         break</p> <pre><code>frame = cv2.flip(frame, 1)\nheight, width = frame.shape[:2]\ncentrox, centroy = width//2, height//2\n\n# ===============================================================\n# DETECCI\u00d3N 1: PLATAFORMA NEGRA (HSV) - \u00c1REA M\u00c1S GRANDE\n# ===============================================================\nhsv_plat = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)\n\nlower_black = np.array([0, 0, 0])\nupper_black = np.array([180, 255, THRESHOLD_PLATAFORMA])\n\nmask_plataforma = cv2.inRange(hsv_plat, lower_black, upper_black)\n\nkernel_plat = np.ones((7,7), np.uint8)\nmask_plataforma = cv2.morphologyEx(mask_plataforma, cv2.MORPH_CLOSE, kernel_plat)\nmask_plataforma = cv2.morphologyEx(mask_plataforma, cv2.MORPH_OPEN, kernel_plat)\nmask_plataforma = cv2.dilate(mask_plataforma, kernel_plat, iterations=1)\n\ncontours_plat, _ = cv2.findContours(mask_plataforma, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\narea_max_plat = 0\ncontorno_plat = None\ncentro_plataforma = None\nrectangulo_info = None\n\nfor c in contours_plat:\n    area = cv2.contourArea(c)\n    if area &gt; area_max_plat and area &gt; AREA_MIN_PLATAFORMA:\n        area_max_plat = area\n        contorno_plat = c\n        rectangulo_info = cv2.minAreaRect(c)\n\n        M = cv2.moments(c)\n        if M[\"m00\"] != 0:\n            cx_plat = int(M[\"m10\"] / M[\"m00\"])\n            cy_plat = int(M[\"m01\"] / M[\"m00\"])\n            centro_plataforma = (cx_plat, cy_plat)\n\n# ===============================================================\n# DETECCI\u00d3N 2: PELOTA AZUL\n# ===============================================================\nhsv = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)\nmask_pelota = cv2.inRange(hsv, LOW_BLUE, HIGH_BLUE)\n\nkernel_pelota = np.ones((5,5), np.uint8)\nmask_pelota = cv2.morphologyEx(mask_pelota, cv2.MORPH_OPEN, kernel_pelota)\nmask_pelota = cv2.morphologyEx(mask_pelota, cv2.MORPH_CLOSE, kernel_pelota)\nmask_pelota = cv2.dilate(mask_pelota, kernel_pelota, iterations=1)\n\ncontours_pelota, _ = cv2.findContours(mask_pelota, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\narea_max_pelota = 0\ncontorno_pelota = None\ncentro_pelota = None\nradio_pelota = 0\n\nfor c in contours_pelota:\n    area = cv2.contourArea(c)\n    if area &gt; area_max_pelota:\n        area_max_pelota = area\n        contorno_pelota = c\n        (x_pel, y_pel), radio_pelota = cv2.minEnclosingCircle(c)\n        if radio_pelota &gt; RADIO_MIN_PELOTA and area &gt; AREA_MIN_PELOTA:\n            centro_pelota = (int(x_pel), int(y_pel))\n\n# ===============================================================\n# VISUALIZACI\u00d3N\n# ===============================================================\nout_original = frame.copy()\n\nmask_combinada = cv2.bitwise_or(mask_plataforma, mask_pelota)\nout_deteccion = cv2.cvtColor(mask_combinada, cv2.COLOR_GRAY2BGR)\n\nout_deteccion[mask_plataforma &gt; 0] = [255, 0, 0]\nout_deteccion[mask_pelota &gt; 0] = [0, 255, 255]\n\n# ===============================================================\n# CALCULAR TIEMPO\n# ===============================================================\ncurrent_time = time.time()\ndt = current_time - prev_time\nprev_time = current_time\nif dt &lt; 0.001:\n    dt = 0.001\n\n# ===============================================================\n# CONTROL PID - SOLO CAMBIO: ERROR X\n# ===============================================================\nplataforma_detectada = (contorno_plat is not None and area_max_plat &gt; AREA_MIN_PLATAFORMA and centro_plataforma is not None)\npelota_detectada = (contorno_pelota is not None and centro_pelota is not None)\n\nif plataforma_detectada:\n    if rectangulo_info:\n        box = cv2.boxPoints(rectangulo_info)\n        box = np.intp(box)\n        cv2.drawContours(out_original, [box], 0, (0, 255, 0), 3)\n        cv2.drawContours(out_deteccion, [box], 0, (0, 255, 0), 2)\n\n    cv2.circle(out_original, centro_plataforma, 12, (0, 255, 0), 3)\n    cv2.circle(out_original, centro_plataforma, 5, (0, 255, 0), -1)\n    cv2.putText(out_original, \"PLATAFORMA\", (centro_plataforma[0]-40, centro_plataforma[1]-20),\n               cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 255, 0), 2)\n\n    if pelota_detectada:\n        cv2.circle(out_original, centro_pelota, int(radio_pelota), (0, 255, 255), 2)\n        cv2.circle(out_original, centro_pelota, 5, (255, 0, 0), -1)\n        cv2.putText(out_original, \"PELOTA\", (centro_pelota[0]-30, centro_pelota[1]+25),\n                   cv2.FONT_HERSHEY_SIMPLEX, 0.5, (255, 255, 0), 2)\n        QQQ\n        cv2.line(out_original, centro_plataforma, centro_pelota, (255, 0, 255), 2)\n        cv2.line(out_deteccion, centro_plataforma, centro_pelota, (255, 255, 255), 2)\n\n        # ===============================================================\n        # CALCULAR ERROR: Pelota respecto al centro de la plataforma\n        # SOLO CAMBIO: X sin signo negativo\n        # ===============================================================\n        error_x = (centro_pelota[0] - centro_plataforma[0])  # CORREGIDO X\n        error_y = (centro_pelota[1] - centro_plataforma[1])  # Y sigue invertido\n\n        if abs(error_x) &lt; DEAD_ZONE: \n            error_x = 0\n        if abs(error_y) &lt; DEAD_ZONE: \n            error_y = 0\n\n        integral_x += error_x * dt\n        integral_y += error_y * dt\n        integral_x = constrain(integral_x, -MAX_INTEGRAL, MAX_INTEGRAL)\n        integral_y = constrain(integral_y, -MAX_INTEGRAL, MAX_INTEGRAL)\n\n        derivative_x = (error_x - prev_error_x) / dt\n        derivative_y = (error_y - prev_error_y) / dt\n\n        output_x = Kp*error_x + Ki*integral_x + Kd*derivative_x\n        output_y = Kp*error_y + Ki*integral_y + Kd*derivative_y\n\n        prev_error_x = error_x\n        prev_error_y = error_y\n\n        delta_x = output_x * 0.15\n        delta_y = output_y * 0.15\n\n        target_x = center_angle + delta_x\n        target_y = center_angle + delta_y\n\n        current_x = current_x * (1 - smoothing) + target_x * smoothing\n        current_y = current_y * (1 - smoothing) + target_y * smoothing\n\n        current_x = constrain(current_x, 0, 110)\n        current_y = constrain(current_y, 0, 110)\n\n        if esp32:\n            mensaje = f\"{int(current_x)},{int(current_y)}\\n\"\n            try:\n                esp32.write(mensaje.encode())\n                if esp32.in_waiting &gt; 0:\n                    respuesta = esp32.readline().decode('utf-8', errors='ignore').strip()\n                    if respuesta and frame_count % 30 == 0:\n                        print(f\"\ud83d\udce1 ESP32: {respuesta}\")\n            except Exception as e:\n                if frame_count % 30 == 0:\n                    print(f\"\u2717 Error: {e}\")\n\n        if frame_count % 5 == 0:\n            print(f\"\u2713 X={int(current_x):3d}\u00b0 Y={int(current_y):3d}\u00b0 | Err X={-error_x:4d} Y={-error_y:4d} | Out X={output_x:6.1f} Y={output_y:6.1f}\")\n\n        cv2.putText(out_original, f\"Error X:{-error_x} Y:{-error_y}\", (10,30),\n                    cv2.FONT_HERSHEY_SIMPLEX, 0.6, (255,255,0), 2)\n        cv2.putText(out_original, f\"Servo X:{int(current_x)} Y:{int(current_y)}\", (10,60),\n                    cv2.FONT_HERSHEY_SIMPLEX, 0.6, (255,255,0), 2)\n        cv2.putText(out_original, f\"Distancia: {int(np.sqrt(error_x**2 + error_y**2))} px\", (10,90),\n                    cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0,255,255), 2)\n    else:\n        cv2.putText(out_original, \"PELOTA NO DETECTADA\", (10,30),\n                    cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0,165,255), 2)\n\n        integral_x = 0\n        integral_y = 0\n        prev_error_x = 0\n        prev_error_y = 0\n\n        current_x = current_x * (1 - smoothing*0.5) + center_angle * smoothing * 0.5\n        current_y = current_y * (1 - smoothing*0.5) + center_angle * smoothing * 0.5\n\n        if esp32 and frame_count % 10 == 0:\n            try:\n                esp32.write(f\"{int(current_x)},{int(current_y)}\\n\".encode())\n            except:\n                pass\n\n        if frame_count % 30 == 0:\n            print(f\" Solo plataforma. Centrando: X={int(current_x)}\u00b0 Y={int(current_y)}\u00b0\")\nelse:\n    cv2.putText(out_original, \"PLATAFORMA NO DETECTADA\", (10,30),\n                cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0,0,255), 2)\n\n    integral_x = 0\n    integral_y = 0\n    prev_error_x = 0\n    prev_error_y = 0\n\n    current_x = current_x * (1 - smoothing*0.5) + center_angle * smoothing * 0.5\n    current_y = current_y * (1 - smoothing*0.5) + center_angle * smoothing * 0.5\n\n    if esp32 and frame_count % 10 == 0:\n        try:\n            esp32.write(f\"{int(current_x)},{int(current_y)}\\n\".encode())\n        except:\n            pass\n\n    if frame_count % 30 == 0:\n        print(f\" Sin detecci\u00f3n. Centrando: X={int(current_x)}\u00b0 Y={int(current_y)}\u00b0\")\n\ncv2.circle(out_original, (centrox, centroy), DEAD_ZONE, (128,128,128), 1)\ncv2.line(out_original, (centrox-15, centroy), (centrox+15, centroy), (128,128,128), 1)\ncv2.line(out_original, (centrox, centroy-15), (centrox, centroy+15), (128,128,128), 1)\n\ncv2.putText(out_original, f\"Plat:{int(area_max_plat)} Pel:{int(area_max_pelota)}\", (10,height-40),\n            cv2.FONT_HERSHEY_SIMPLEX, 0.5, (200,200,200), 1)\ncv2.putText(out_original, f\"Threshold:{THRESHOLD_PLATAFORMA} (1/2)\", (10,height-15),\n            cv2.FONT_HERSHEY_SIMPLEX, 0.5, (200,200,200), 1)\n\ncv2.putText(out_original, f\"PID: Kp={Kp:.2f} Ki={Ki:.3f} Kd={Kd:.2f}\", (10,120),\n            cv2.FONT_HERSHEY_SIMPLEX, 0.5, (255,200,0), 2)\n\nframe_count += 1\nif time.time() - fps_time &gt; 1.0:\n    fps = frame_count\n    frame_count = 0\n    fps_time = time.time()\n\ncv2.putText(out_original, f\"FPS: {fps}\", (width-100, 30),\n            cv2.FONT_HERSHEY_SIMPLEX, 0.6, (0,255,0), 2)\n\ncv2.imshow(\"Sistema de Balance - Original\", out_original)\ncv2.imshow(\"Deteccion: Plataforma(Azul) + Pelota(Amarillo)\", out_deteccion)\n\nkey = cv2.waitKey(1) &amp; 0xFF\nif key == ord('q'):\n    break\nelif key == ord('c'):\n    integral_x = 0\n    integral_y = 0\n    print(\"Integrales reseteadas\")\nelif key == ord('1'):\n    THRESHOLD_PLATAFORMA = max(10, THRESHOLD_PLATAFORMA - 5)\n    print(f\"Threshold: {THRESHOLD_PLATAFORMA}\")\nelif key == ord('2'):\n    THRESHOLD_PLATAFORMA = min(250, THRESHOLD_PLATAFORMA + 5)\n    print(f\"Threshold: {THRESHOLD_PLATAFORMA}\")\n</code></pre> <p>print(\"\\nCerrando sistema...\") cap.release() if esp32:     esp32.write(f\"{center_angle},{center_angle}\\n\".encode())     time.sleep(0.1)     esp32.close()     print(\"Conexi\u00f3n serial cerrada\") cv2.destroyAllWindows() print(\"Sistema finalizado\")</p>"},{"location":"ProyectoFinal/#codigo-esp32-arduino","title":"C\u00f3digo ESP32 / Arduino","text":"<p>cpp</p>"},{"location":"ProyectoFinal/#include","title":"include  <p>// =============== CONFIGURACI\u00d3N DE PINES =============== const int PIN_SERVO_X = 18;  // Servo que controla eje X (horizontal) const int PIN_SERVO_Y = 19;  // Servo que controla eje Y (vertical)</p> <p>// =============== CONFIGURACI\u00d3N DE SERVOS =============== Servo servoX; Servo servoY;</p> <p>// Par\u00e1metros PWM para servos (ajustar seg\u00fan tu modelo) const int PWM_MIN = 500;   // Ancho de pulso m\u00ednimo en microsegundos const int PWM_MAX = 2400;  // Ancho de pulso m\u00e1ximo en microsegundos</p> <p>// =============== POSICI\u00d3N INICIAL =============== const int CENTRO = 35;     // Posici\u00f3n central (0-180 grados)</p> <p>// =============== VARIABLES DE COMUNICACI\u00d3N =============== String inputString = \"\";         // Buffer para datos recibidos bool stringComplete = false;     // Bandera de comando completo</p> <p>// =============== VARIABLES DE CONTROL =============== int posicionX = CENTRO; int posicionY = CENTRO; unsigned long ultimoComando = 0; const unsigned long TIMEOUT = 2000;  // Timeout en ms (volver al centro si no hay datos)</p> <p>// =============== CONFIGURACI\u00d3N INICIAL =============== void setup() {   // Iniciar comunicaci\u00f3n serial   Serial.begin(115200);</p> <p>// Reservar memoria para el buffer   inputString.reserve(20);</p> <p>// Configurar servos con par\u00e1metros PWM personalizados   servoX.attach(PIN_SERVO_X, PWM_MIN, PWM_MAX);   servoY.attach(PIN_SERVO_Y, PWM_MIN, PWM_MAX);</p> <p>// Mover a posici\u00f3n inicial centrada   servoX.write(CENTRO);   servoY.write(CENTRO);</p> <p>// Esperar estabilizaci\u00f3n   delay(500);</p> <p>// Mensaje de inicio   Serial.println(\"========================================\");   Serial.println(\"ESP32 - Sistema de Balance de Pelota\");   Serial.println(\"========================================\");   Serial.println(\"Configuracion:\");   Serial.print(\"  - Servo X en pin GPIO \");   Serial.println(PIN_SERVO_X);   Serial.print(\"  - Servo Y en pin GPIO \");   Serial.println(PIN_SERVO_Y);   Serial.print(\"  - Centro: \");   Serial.print(CENTRO);   Serial.println(\" grados\");   Serial.print(\"  - PWM: \");   Serial.print(PWM_MIN);   Serial.print(\"-\");   Serial.print(PWM_MAX);   Serial.println(\" us\");   Serial.println(\"========================================\");   Serial.println(\"Sistema listo. Esperando datos...\");   Serial.println(\"Formato: X,Y (ejemplo: 90,85)\");   Serial.println(\"========================================\");</p> <p>ultimoComando = millis(); }</p> <p>// =============== BUCLE PRINCIPAL =============== void loop() {   // Leer datos seriales disponibles   while (Serial.available()) {     char inChar = (char)Serial.read();</p> <pre><code>// Si es salto de l\u00ednea, el comando est\u00e1 completo\nif (inChar == '\\n' || inChar == '\\r') {\n  if (inputString.length() &gt; 0) {\n    stringComplete = true;\n  }\n} else {\n  // Agregar caracter al buffer\n  inputString += inChar;\n}\n</code></pre> <p>}</p> <p>// Procesar comando si est\u00e1 completo   if (stringComplete) {     procesarComando();     inputString = \"\";     stringComplete = false;     ultimoComando = millis();   }</p> <p>// Timeout: volver al centro si no hay comandos recientes   if (millis() - ultimoComando &gt; TIMEOUT) {     volverAlCentro();     ultimoComando = millis();   } }</p> <p>// =============== FUNCI\u00d3N: PROCESAR COMANDO =============== void procesarComando() {   // Buscar la coma separadora   int comaIndex = inputString.indexOf(',');</p> <p>if (comaIndex &gt; 0) {     // Extraer valores X e Y     String valorXStr = inputString.substring(0, comaIndex);     String valorYStr = inputString.substring(comaIndex + 1);</p> <pre><code>// Convertir a enteros\nint xRecibido = valorXStr.toInt();\nint yRecibido = valorYStr.toInt();\n\n// Validar y limitar al rango 0-180\nxRecibido = constrain(xRecibido, 0, 180);\nyRecibido = constrain(yRecibido, 0, 180);\n\n// Actualizar posiciones\nposicionX = xRecibido;\nposicionY = yRecibido;\n\n// Mover servos\nservoX.write(posicionX);\nservoY.write(posicionY);\n\n// Enviar confirmaci\u00f3n a Python\nSerial.print(\"Recibido: \");\nSerial.print(posicionX);\nSerial.print(\",\");\nSerial.println(posicionY);\n</code></pre> <p>} else {     // Comando inv\u00e1lido (sin coma)     Serial.print(\"Error: Formato invalido '\");     Serial.print(inputString);     Serial.println(\"'. Use: X,Y\");   } }</p> <p>// =============== FUNCI\u00d3N: VOLVER AL CENTRO =============== void volverAlCentro() {   static bool mensajeMostrado = false;</p> <p>// Movimiento suave hacia el centro   if (posicionX != CENTRO || posicionY != CENTRO) {     if (!mensajeMostrado) {       Serial.println(\"Timeout: Volviendo al centro...\");       mensajeMostrado = true;     }</p> <pre><code>// Acercar gradualmente al centro\nif (posicionX &lt; CENTRO) posicionX++;\nif (posicionX &gt; CENTRO) posicionX--;\nif (posicionY &lt; CENTRO) posicionY++;\nif (posicionY &gt; CENTRO) posicionY--;\n\n// Mover servos\nservoX.write(posicionX);\nservoY.write(posicionY);\n\ndelay(20);  // Movimiento suave\n</code></pre> <p>} else {     mensajeMostrado = false;   } } ```</p>","text":""},{"location":"ProyectoFinal/#instalacion-y-uso","title":"Instalaci\u00f3n y Uso","text":"<ol> <li>Cargar el c\u00f3digo en el ESP32.</li> <li>Ejecutar el script de Python.</li> <li>Verificar que la c\u00e1mara detecte la plataforma.</li> <li>Ajustar par\u00e1metros PID con los sliders.</li> <li>Colocar la pelota sobre la plataforma.</li> <li>Observar la estabilizaci\u00f3n en tiempo real.</li> </ol>"},{"location":"ProyectoFinal/#conclusiones","title":"Conclusiones","text":"<ul> <li>El robot utiliza visi\u00f3n artificial para estimar posici\u00f3n.</li> <li>El PID corrige la inclinaci\u00f3n con alta precisi\u00f3n.</li> <li>La estructura mec\u00e1nica y servos de alto torque permiten estabilidad.</li> <li>Se obtuvo un robot funcional capaz de mantener el equilibrio de una pelota.</li> </ul>"},{"location":"ProyectoFinal/#licencia","title":"Licencia","text":"<p>Proyecto acad\u00e9mico desarrollado para fines educativos.</p>"},{"location":"comandos/","title":"Encabezados","text":"<pre><code># T\u00edtulo H1\n## T\u00edtulo H2\n### T\u00edtulo H3\n</code></pre>"},{"location":"comandos/#titulo-h1","title":"T\u00edtulo H1","text":""},{"location":"comandos/#titulo-h2","title":"T\u00edtulo H2","text":""},{"location":"comandos/#titulo-h3","title":"T\u00edtulo H3","text":""},{"location":"comandos/#enfasis-y-codigo-en-linea","title":"\u00c9nfasis y c\u00f3digo en l\u00ednea","text":"<pre><code>**negritas**, *cursivas*, ~~tachado~~, `c\u00f3digo en l\u00ednea`\n</code></pre> <p>negritas, cursivas, ~~tachado~~, <code>c\u00f3digo en l\u00ednea</code></p>"},{"location":"comandos/#citas-blockquote","title":"Citas (blockquote)","text":"<pre><code>&gt; Esta es una cita destacada.\n&gt; Puede tener m\u00faltiples l\u00edneas.\n</code></pre> <p>Esta es una cita destacada. Puede tener m\u00faltiples l\u00edneas.</p>"},{"location":"comandos/#enlaces","title":"Enlaces","text":"<pre><code>[Enlace directo](https://www.iberopuebla.mx/)\n\n[Texto del enlace de referencia][doc-ref]\n\n[doc-ref]: https://www.iberopuebla.mx//docs \"T\u00edtulo opcional\"\n</code></pre> <p>Enlace directo</p> <p>Texto del enlace de referencia</p>"},{"location":"comandos/#listas-vinetas-numeradas-y-de-tareas","title":"Listas: vi\u00f1etas, numeradas y de tareas","text":"<pre><code>- Item A\n    * Subitem A.1\n    * Subitem A.2\n- Item B\n    - Subitem B.1\n    - Subitem B.2\n\n1.  Paso 1\n    1.  Paso 1.1\n    2.  Paso 1.2\n        1.  Paso 1.2.1\n        2.  Paso 1.2.2\n\n- [x] Hecho\n- [ ] Pendiente\n</code></pre> <ul> <li>Item A<ul> <li>Subitem A.1</li> <li>Subitem A.2</li> </ul> </li> <li>Item B<ul> <li>Subitem B.1</li> <li>Subitem B.2</li> </ul> </li> </ul> <ol> <li> <p>Paso 1</p> <ol> <li>Paso 1.1</li> <li>Paso 1.2<ol> <li>Paso 1.2.1</li> <li>Paso 1.2.2</li> </ol> </li> </ol> </li> <li> <p> Hecho</p> </li> <li> Pendiente</li> </ol>"},{"location":"comandos/#tablas","title":"Tablas","text":"<pre><code>| Componente | Cant. | Nota        |\n|-----------:|:-----:|-------------|\n| Sensor X   | 2     | I2C         |\n| MCU Y      | 1     | WiFi/BLE    |\n</code></pre> Componente Cant. Nota Sensor X 2 I2C MCU Y 1 WiFi/BLE"},{"location":"comandos/#imagenes","title":"Im\u00e1genes","text":"<pre><code>![Diagrama del sistema](recursos/imgs/ibero.jpeg)\n\n&lt;!-- Control de tama\u00f1o usando HTML (cuando se requiera) --&gt;\n&lt;img src=\"../recursos/imgs/ibero.jpeg\" alt=\"Diagrama del sistema\" width=\"420\"&gt;\n</code></pre>"},{"location":"comandos/#pdfs-enlace-y-embebido","title":"PDFs (enlace y embebido)","text":"<pre><code>[Descargar especificaci\u00f3n (PDF)](recursos/archivos/Calendario.pdf)\n\n&lt;!-- Embed (requiere navegador compatible) --&gt;\n&lt;object data=\"recursos/archivos/Calendario.pdf\" type=\"application/pdf\" width=\"100%\" height=\"600\"&gt;\n  &lt;p&gt;No se pudo mostrar el PDF. &lt;a href=\"../recursos/archivos/Calendario.pdf\"&gt;Descargar&lt;/a&gt;&lt;/p&gt;\n&lt;/object&gt;\n</code></pre> <p>Descargar especificaci\u00f3n (PDF)</p>"},{"location":"comandos/#admonitions-material","title":"Admonitions (Material)","text":"<pre><code>!!! note \"Nota\"\n    Esto es una nota informativa.\n\n!!! tip \"Sugerencia\"\n    Un consejo breve para el usuario.\n\n!!! warning \"Advertencia\"\n    Precauciones o riesgos a considerar.\n\n??? info \"M\u00e1s informaci\u00f3n (colapsable)\"\n    Contenido adicional que se puede expandir.\n</code></pre> <p>Nota</p> <p>Esto es una nota informativa.</p> <p>Sugerencia</p> <p>Un consejo breve para el usuario.</p> <p>Advertencia</p> <p>Precauciones o riesgos a considerar.</p> M\u00e1s informaci\u00f3n (colapsable) <p>Contenido adicional que se puede expandir.</p>"},{"location":"comandos/#codigo-con-resaltado","title":"C\u00f3digo con resaltado","text":"<p><pre><code>```python\ndef medir(canal: int) -&gt; dict:\n    # Simulaci\u00f3n de lectura\n    return {\"canal\": canal, \"valor\": 523, \"unidad\": \"mV\"}\n\nprint(medir(1))\n</code></pre> <pre><code>```python\ndef medir(canal: int) -&gt; dict:\n    # Simulaci\u00f3n de lectura\n    return {\"canal\": canal, \"valor\": 523, \"unidad\": \"mV\"}\n\nprint(medir(1))\n</code></pre></p>"},{"location":"comandos/#separador-horizontal","title":"Separador horizontal","text":"<pre><code>---\n</code></pre>"},{"location":"comandos/#listas-anidadas-con-codigo-y-notas","title":"Listas anidadas con c\u00f3digo y notas","text":"<pre><code>- **M\u00f3dulo A**\n  - Funci\u00f3n: `procesar()`\n  - Entrada:\n    - `signal` (float)\n    - `freq` (Hz)\n  - Salida:\n    - JSON con `valor`, `unidad`\n  - !!! note\n        Documenta rangos v\u00e1lidos y casos borde.\n</code></pre> <ul> <li>M\u00f3dulo A</li> <li>Funci\u00f3n: <code>procesar()</code></li> <li>Entrada:<ul> <li><code>signal</code> (float)</li> <li><code>freq</code> (Hz)</li> </ul> </li> <li>Salida:<ul> <li>JSON con <code>valor</code>, <code>unidad</code></li> </ul> </li> <li> <p>Note</p> <pre><code>Documenta rangos v\u00e1lidos y casos borde.\n</code></pre> </li> </ul>"},{"location":"comandos/#bloques-de-cita-con-codigo-pseudo-logs","title":"Bloques de cita con c\u00f3digo (pseudo-logs)","text":"<pre><code>&gt; **Log:**\n&gt; ```\n&gt; [12:00:00] Init OK\n&gt; [12:00:01] Conectando a I2C...\n&gt; [12:00:02] Lectura: 523 mV\n&gt; ```\n</code></pre> <p>Log: <pre><code>[12:00:00] Init OK\n[12:00:01] Conectando a I2C...\n[12:00:02] Lectura: 523 mV\n</code></pre></p>"},{"location":"ejemplo/","title":"\ud83d\udcda Ejemplo de Documentaci\u00f3n del Proyecto","text":"<p>Plantilla gen\u00e9rica para documentar proyectos acad\u00e9micos o de ingenier\u00eda. Copia y adapta las secciones seg\u00fan tu necesidad.</p>"},{"location":"ejemplo/#1-resumen","title":"1) Resumen","text":"<ul> <li>Nombre del proyecto: Mi Proyecto </li> <li>Equipo / Autor(es): Nombre(s) </li> <li>Curso / Asignatura: Nombre del curso </li> <li>Fecha: DD/MM/AAAA </li> <li>Descripci\u00f3n breve: Una o dos l\u00edneas que expliquen qu\u00e9 hace y por qu\u00e9.</li> </ul> <p>Consejo</p> <p>Mant\u00e9n este resumen corto (m\u00e1x. 5 l\u00edneas). Lo dem\u00e1s va en secciones espec\u00edficas.</p>"},{"location":"ejemplo/#2-objetivos","title":"2) Objetivos","text":"<ul> <li>General: Qu\u00e9 se pretende lograr en t\u00e9rminos amplios.</li> <li>Espec\u00edficos:</li> <li>OE1\u2026</li> <li>OE2\u2026</li> <li>OE3\u2026</li> </ul>"},{"location":"ejemplo/#3-alcance-y-exclusiones","title":"3) Alcance y Exclusiones","text":"<ul> <li>Incluye: Qu\u00e9 funcionalidades/entregables s\u00ed est\u00e1n en el proyecto.</li> <li>No incluye: Qu\u00e9 queda fuera para evitar malentendidos.</li> </ul>"},{"location":"ejemplo/#4-requisitos","title":"4) Requisitos","text":"<p>Software - SO compatible (Windows/Linux/macOS) - Python 3.x / Node 18+ / Arduino IDE / etc. - Dependencias (p. ej., pip/requirements, npm packages)</p> <p>Hardware (si aplica) - MCU / Sensores / Actuadores / Fuente de poder - Herramientas (mult\u00edmetro, caut\u00edn, etc.)</p> <p>Conocimientos previos - Programaci\u00f3n b\u00e1sica en X - Electr\u00f3nica b\u00e1sica - Git/GitHub</p>"},{"location":"ejemplo/#5-instalacion","title":"5) Instalaci\u00f3n","text":"<pre><code># 1) Clonar\ngit clone https://github.com/&lt;usuario&gt;/&lt;repo&gt;.git\ncd &lt;repo&gt;\n\n# 2) (Opcional) Crear entorno virtual\npython -m venv .venv\n# macOS/Linux\nsource .venv/bin/activate\n# Windows (PowerShell)\n.venv\\Scripts\\Activate.ps1\n\n# 3) Instalar dependencias (ejemplos)\npip install -r requirements.txt\n# o, si es Node:\nnpm install\n</code></pre>"},{"location":"gitcmds/","title":"\ud83d\ude80 Comandos b\u00e1sicos de Git (primeros pasos)","text":"<p>En este curso solo usaremos los comandos esenciales de Git para trabajar con repositorios.</p>"},{"location":"gitcmds/#1-clonar-un-repositorio","title":"1. Clonar un repositorio","text":"<p>Copia un proyecto de GitHub a tu computadora.</p> <pre><code>git clone https://github.com/usuario/repositorio.git\n</code></pre>"},{"location":"gitcmds/#2-verificar-cambios","title":"2. Verificar cambios","text":"<p>Muestra qu\u00e9 archivos has modificado o agregado.</p> <pre><code>git status\n</code></pre>"},{"location":"gitcmds/#3-preparar-cambios","title":"3. Preparar cambios","text":"<p>Agrega archivos para guardarlos en el pr\u00f3ximo commit.</p> <pre><code>git add archivo.txt\ngit add .   # agrega todos los archivos modificados\n</code></pre>"},{"location":"gitcmds/#4-guardar-cambios-commit","title":"4. Guardar cambios (commit)","text":"<p>Guarda tus cambios con un mensaje descriptivo.</p> <pre><code>git commit -m \"Descripci\u00f3n breve de los cambios\"\n</code></pre>"},{"location":"gitcmds/#5-subir-cambios-al-repositorio-push","title":"5. Subir cambios al repositorio (push)","text":"<p>Env\u00eda tus commits locales al repositorio en GitHub.</p> <pre><code>git push origin main\n</code></pre>"},{"location":"gitcmds/#6-traer-cambios-del-remoto-pull","title":"6. Traer cambios del remoto (pull)","text":"<p>Actualiza tu proyecto con los \u00faltimos cambios de GitHub.</p> <pre><code>git pull origin main\n</code></pre>"},{"location":"gitcmds/#flujo-tipico-de-trabajo","title":"Flujo t\u00edpico de trabajo","text":"<ol> <li> <p>Traer cambios del remoto <pre><code>git pull origin main\n</code></pre></p> </li> <li> <p>Editar tus archivos de proyecto.</p> </li> <li> <p>Preparar los cambios <pre><code>git add .\n</code></pre></p> </li> <li> <p>Guardar los cambios <pre><code>git commit -m \"Mensaje descriptivo\"\n</code></pre></p> </li> <li> <p>Enviar los cambios al remoto <pre><code>git push origin main\n</code></pre></p> </li> </ol> <p>Consejo</p> <p>Piensa en este ciclo como un loop infinito: cada vez que quieras contribuir \u2192 primero <code>pull</code>, despu\u00e9s <code>add</code> + <code>commit</code>, y finalmente <code>push</code>.</p>"}]}